数据包长度表示 = '''
涉及数据包长度的表示，均用 2 bytes 的整型值表示，大端
'''

地址编码协议 = '''
# 至少在Python中，网络地址用字符串表示更为方便，在此也使用这种方法
# 字符串编码为 utf-8
N bytes:  编码后的地址
2 bytes:  端口
'''

主控连接数据传输协议 = '''
2 bytes: 数据包大小  # 这部分不属于自数据包的解释范畴，仅用来进行数据传输时，确保包的完整性
1 byte : 操作类型
	0 新建映射 后接：
		2 bytes: 分配的ID
		2 bytes： 进行编码后的数据包长度
			需映射的地址编码
		2 bytes： 进行编码后的数据包长度
			反向连接的地址编码
	废弃：1 映射确认 后接：
		2 bytes: ID
	废弃：2 映射错误 后接：
		2 bytes: ID
	3 关闭映射 后接：
		2 bytes: ID
	4 关闭所有映射
'''

映射连接数据传输协议 = '''
2 bytes: 数据包大小
1 byte : 操作类型
	0 新建连接 后接：
		2 bytes: 分配的ID
	1 连接确认 后接：
		2 bytes: ID
	2 连接错误 后接：
		2 bytes: ID
	3 关闭连接 后接：
		2 bytes: ID
	4 关闭所有连接

	5 数据发送： 后接：
		2 bytes: ID
		N bytes: 数据包
'''

模块  = '''
本地主控：
	新建、控制与客户机的连接
	握手：
	控制相应的端口映射

转发服务端：
	监听客户机发起的连接，有效连接只能有一个（最后一个通过验证的连接）
	本地傀儡服务端接收的数据通过这条连接进行数据传输
	握手：

本地傀儡服务端：
	为客户机相应端口的傀儡服务端口，监听本地应用发起的连接。
	有连接进入时，通过 转发服务端的连接 告知客户机新建至指定端口的连接。
	连接建立后，（？）主动发送数据？另有线程轮询？

客户机傀儡客户端：
	连接即可，数据有轮询。

客户机主连接端：
	连接服务器
	新建端口映射

'''

握手 = '''
(1) 客户端发送 服务端端口号
(2) 服务端回复 (该端口号 - 1)
'''

线程模型 = '''
本地：
	主线程？
	1个监听线程,监听两个端口
	一个接收线程,负责接受本地已经客户机发来的数据，并进行数据解包或封包工作。 select时添加select内容？
	一个write线程（有数据时写，无数据时睡眠）

客户机：
	主线程？
	数据接收线程，解包，封包
	数据处理线程，将接收到的数据发送给指定socket，或者新建相应连接,结果如何返回？

'''
